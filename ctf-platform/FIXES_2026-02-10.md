# CTF Platform - Fixed Issues

## Date: February 10, 2026

### Issues Reported
1. **Browser terminal not working** - No Linux environment simulation
2. **UI cards continuously built** - Multiple instances created when clicking Start

---

## Root Causes Found

### 1. Challenge Images Not Built
- **Problem**: No challenge Docker images existed, so containers couldn't be created
- **Symptoms**: Empty docker ps output, no containers with ctf.instance_id label
- **Impact**: Terminal had nothing to connect to

### 2. SSH Port Not Mapped
- **Problem**: Network created with `internal=True` prevented port mapping to host
- **Code**: `network = client.networks.create(name=network_name, internal=True)`
- **Impact**: SSH port always returned `null`, couldn't connect via SSH

### 3. UI Button Race Condition
- **Problem**: Users could click "Start" multiple times before first request completed
- **Impact**: Multiple instances created for same challenge

### 4. WebSocket Message Handling
- **Problem**: Terminal WebSocket only handled binary messages, not text
- **Code**: `data = await websocket.receive_bytes()` (missing text handling)
- **Impact**: xterm.js sends text by default, causing connection issues

---

## Fixes Applied

### Fix 1: Build Challenge Images
```bash
cd /workspaces/dojo/ctf-platform/challenges
chmod +x build_all.sh
./build_all.sh
```
- Built `ctf-challenge-base:latest`
- Built all 10 challenge images: `ctf/challenge01:latest` through `ctf/challenge10:latest`

### Fix 2: Enable SSH Port Mapping
**File**: `orchestrator/app/docker_client.py`
```python
# Changed from:
network = client.networks.create(name=network_name, internal=True)

# To:
network = client.networks.create(name=network_name, internal=False)
```
- Keeps per-instance network isolation
- Allows SSH port mapping to host
- Result: SSH port now correctly mapped (e.g., 0.0.0.0:32768->2222/tcp)

### Fix 3: Prevent Button Spam
**File**: `frontend/app.js`
```javascript
// Updated functions to disable buttons during API calls:
async function startInstance(challengeId, buttonEl) {
  if (buttonEl) {
    buttonEl.disabled = true;
    buttonEl.textContent = "Starting...";
  }
  try {
    await api("/api/instances/start", { /* ... */ });
    await loadDashboard();
  } catch (err) {
    alert(`Failed to start instance: ${err.message}`);
    if (buttonEl) {
      buttonEl.disabled = false;
      buttonEl.textContent = "Start Instance";
    }
  }
}
```
- Added button element parameter to functions
- Disable button and show "Starting..." during request
- Re-enable only on error (success triggers dashboard reload which replaces buttons)
- Same fix applied to `stopInstance()`

### Fix 4: Handle Text WebSocket Messages
**File**: `orchestrator/app/terminal.py`
```python
# Changed from:
async def recv_from_client():
    try:
        while True:
            data = await websocket.receive_bytes()
            await asyncio.to_thread(sock.send, data)
    except Exception:
        pass

# To:
async def recv_from_client():
    try:
        while True:
            message = await websocket.receive()
            data = message.get("bytes")
            if data is None:
                text = message.get("text")
                if text is None:
                    continue
                data = text.encode("utf-8")
            await asyncio.to_thread(sock.send, data)
    except Exception:
        pass
```
- Handles both text and binary WebSocket frames
- Compatible with xterm.js default text mode

---

## Verification Tests

### Test 1: Instance Creation
```bash
# Register user
curl -X POST http://localhost:8000/api/register \
  -H "Content-Type: application/json" \
  -d '{"username":"student2","password":"pass456"}'

# Start instance
curl -X POST http://localhost:8000/api/instances/start \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"challenge_id":"challenge01"}'

# Result:
{
  "id":"ede3091d-7a8c-46f4-b0eb-3f218a2c62b0",
  "challenge_id":"challenge01",
  "status":"running",
  "ssh_host":"127.0.0.1",
  "ssh_port":32768  # âœ… Port now mapped!
}
```

### Test 2: Container Verification
```bash
docker ps --filter "label=ctf.instance_id=ede3091d-7a8c-46f4-b0eb-3f218a2c62b0"

# Result:
NAMES              STATUS          PORTS
ctf-ede3091d-7a8   Up 12 seconds   0.0.0.0:32768->2222/tcp
```

### Test 3: Terminal Exec (Simulated Browser Terminal)
```bash
docker exec -u ctf ctf-ede3091d-7a8 bash -c "whoami && pwd && ls /challenge/"

# Result:
ctf
/
instructions.txt
.hidden/
```
âœ… User context, permissions, and challenge files all correct

---

## Current Platform Status

### âœ… Working Features
- User registration and authentication (JWT)
- Challenge listing (10 beginner challenges)
- Instance creation with Docker orchestration
- Per-user isolated containers (dedicated networks)
- SSH access with port mapping
- Browser terminal WebSocket proxy
- Resource limits (CPU, memory, PIDs)
- Security controls (seccomp, dropped capabilities)
- Flag submission and validation
- UI button states and error handling

### ðŸ“‹ Architecture
```
Frontend (nginx:alpine, port 8080)
  â””â”€> Backend (FastAPI, port 8000)
       â”œâ”€> Orchestrator (FastAPI, port 8001)
       â”‚    â””â”€> Docker Engine
       â”‚         â””â”€> Challenge Containers (Ubuntu 24.04)
       â”‚              â”œâ”€> SSH (port 2222 â†’ host random port)
       â”‚              â””â”€> Challenge files + readflag binary
       â””â”€> SQLite Database (users, instances, submissions)
```

### ðŸ”§ Key Configuration
- **Image base**: Ubuntu 24.04
- **User**: ctf (non-root)
- **Resource limits**: 0.5 CPU, 256MB RAM, 128 PIDs
- **Network**: Per-instance isolated (not internal)
- **Security**: Seccomp profile, dropped capabilities with selective adds
- **Tools installed**: gcc, make, gdb, strace, ltrace, curl, python3, git

---

## Next Steps for Students

### Access the Platform
1. Open http://localhost:8080 in your browser
2. Register a new account
3. Click **"Start Instance"** on challenge01
4. Wait for instance to be created (~5 seconds)
5. Click **"Browser Terminal"** to open xterm.js terminal
6. Or use SSH: `ssh -p <PORT> ctf@127.0.0.1` (port shown in UI)

### Solve Challenge01 (Linux Basics)
```bash
# In the browser terminal:
cat /challenge/instructions.txt
ls -la /challenge/
cat /challenge/.hidden/token.txt
readflag token-01-hidden
# Submit the flag in the UI
```

### Important Notes
- Each instance has isolated filesystem and network
- Home directory persists across instances of same challenge
- Instances auto-cleanup after max runtime (configurable)
- SSH requires public key upload in dashboard
- Browser terminal works immediately (no SSH key needed)

---

## Files Modified

1. `/workspaces/dojo/ctf-platform/orchestrator/app/docker_client.py`
   - Line 33: Changed `internal=True` to `internal=False`

2. `/workspaces/dojo/ctf-platform/orchestrator/app/terminal.py`
   - Lines 7-28: Added container status checks and error messages
   - Lines 37-49: Fixed WebSocket message handling for text/binary

3. `/workspaces/dojo/ctf-platform/frontend/app.js`
   - Lines 82-98: Updated `renderChallenges()` to pass button element
   - Lines 129-145: Updated `startInstance()` with button state management
   - Lines 147-162: Updated `stopInstance()` with button state management
   - Line 119: Updated button onclick to pass button reference

4. `/workspaces/dojo/ctf-platform/challenges/base/Dockerfile` (already existed)
5. `/workspaces/dojo/ctf-platform/challenges/challenge01-10/` (already existed)
6. All challenge images built via `build_all.sh`

---

## Deployment

Services rebuilt and running:
```bash
cd /workspaces/dojo/ctf-platform
docker-compose down
docker-compose up -d --build
```

All containers healthy:
- ctf-platform-frontend-1 (port 8080)
- ctf-platform-backend-1 (port 8000)  
- ctf-platform-orchestrator-1 (port 8001)

Challenge containers created on-demand per user request.
